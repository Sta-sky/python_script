[TOC]

##### 1、你先做一下自我介绍吧

```
	你好  我叫党远洋，2018年毕业于陇东学院，是一所普通二本院校。毕业后第一份工作在坤盛丰咨车易迅询管理有限公司工作，工作的主要内容是开发一站式服务平台web网站。主要的负责车辆详情页，用户信息，等模块后台逻辑编写，完成前后端数据的交互。使用的框架为django。数据库为mysql。到19年4月份的时候辞职，到了软通动力有限公司。当时做华为的外包项目，云服务器备份。其中python充当的角色为工具开发语言，主要工作内容为，随着云服务的升级迭代，使用python开发的工具对云服务进行安装部署升级。之后由于部门变动，加入了海思部门，主要负责工具的开发 ，有基于django的多任务协同的web工具，也有桌面应用工具。我最大的特点是，在开发的自己模块的同时能较好地推动开发的进度，自我驱动力较强，协同其他同事对任务的进度把控比较好，在上家公司中，这方面获得了领导较好的认可。同时自己也习惯于这种方式，平息喜欢弹弹吉他 ，周末写写小脚本之类的。我的自我介绍就是

```



##### 2、至少列举8个常用模块都有那些

~~~python
os, re, sockte, request, urllib, hashlib, time
~~~

  

##### 3、谈谈你对闭包的理解

~~~pytohn
闭包其实就是两个函数嵌套，内层函数引用外层函数变量，外层函数返回内层函数，这样就构成了一个闭包。
装饰器：
	装饰器是一个特殊的闭包，将函数作为参数传递，在装饰器的内部函数中，对函数做处理，从而完成对函数功能的增加。
~~~



##### 3.1、装饰器的作用

~~~python
优点：
	为已经存在的函数，在并不需要改变该函数的代码的情况下，为函数添加额外的功能，
缺点：
	会改变原函数的函数名；
    解决方式，使用functools中的@wraps（func）中的模块解决。
调用顺序：
	离函数最近的装饰器，最先被调用。
    
~~~



##### 3.2、单例模式

~~~python
单例模式是一种常用的设计模式，在这种设计模式下，对象的类要保证只有一个实例存在。
优点：
	1、防止其他对象实例化此类，保证只存在一个实例。
    2、提供了唯一的实例访问控制。
    3、节约资源，提高性能。
~~~



##### 4、python的is == 两者有什么了解呢

```
两者都是对象的比较，前者比较的是内存地址，后者比较的是数值是否相等。
```



##### 5、lambda表达式得结构，应用场景有哪些呢

```
lambda 传入的值 ：冒号后面是表达式
lambda 变量1，变量2：表达式
map（）映射函数，第一个参数是func，第二个参数是一个列表。
```



##### 6、map()函数

~~~
map函数的结构：
	map（func, [list]）： 
		第一个参数接受一个函数，第二个参数接受一个列表，
		执行过程是将列表中的元素，一次传入func中，执行完成之后，map接受结果，通过for迭代出结果，
		一般与lambda函数结合使用。
~~~



##### 7、python传参数是传值还是传址

~~~python
传递参数类型不同，传递的方式不同：
	变量：传值
	对象：传地址
~~~



##### 8、简述HTTP常见请求头，请求方法（说明get和post区别）

```python
get 官方定义是用来请求获取数据的
post 是用来提交写入数据的。
put 用来覆盖服务器数据
delete 删除指定数据
head 发送请求头。
options 预检请求，在ajax请求发送之前，先发送option请求，返回的是请求头信息，查看请求头中是否支持当前请求。
```



##### 9、深拷贝 跟浅拷贝

```
总结：
	1、浅拷贝
		浅拷贝只做顶层数据类型判断：
		顶层数据类型为可变类型，创建新的内存地址。
		顶层为不可变类型，引用原有内存地址。
	2、深拷贝
		深拷贝做递归数据类型判断，
		递归时遇到可变类型，引用内存地址。
		递归时遇到不可变类型，创建新内存地址。
```



##### 10、静态方法和类方法区别

~~~python
静态方法：相当于类中的一个函数，不需要实例化，可以通过类名直接调用，
类方法：需要对类进行实例化，通过实例化对象进行调用。
~~~

##### 10.1 python中单下划线跟双下划线的区别

```python
单下划线：
	称为 保护变量， 类对象跟子类对象，能访问这些变量。
双下划线：
	称为 私有变量， 只有类对象自己能访问
	
```



##### 11、谈谈python的 GIL

```python
python的GIL全局解释器锁，python在每个进程运行的时候，会给当前进程配置一个解释器，当多个线程在进程中运行的时候，一个线程占用这个解释器，其他线程就无法使用，所以python的多线程，是个伪多线程，只是在不同的线程之间来回切换。从而达到多线程的效果。
	因此一般IO密集型，也就是磁盘读写比较多的，使用多线程，因为读写时cpu要等待，
    计算密集型：用多进程，可充分利用cpu的多核功能。
```



##### 12、tcp的三次握手四次挥手

```pyhton
三次握手：
	1、客户端发起链接请求，
    2、服务端收到消息，返回收到消息标志，表示自己收到要发起链接的请求，并返回客户端，
    3、客户端确认后，建立连接。
四次挥手：
	1、主动方先发起端口请求，
	2、被动方收到请求，并返回确认标志，此时还未断开，
	3、被动方所有任务动作完成，并再次发送端口标志，
	4、主动方收到被动方请求，确认断开，此时完全断开链接。
完整版：
三次握手：
    （1）浏览器发起连接请求，将请求连接报文SYN置为1，生成随机的数字seq = x
    （2）服务器收到请求后，继续将报文SYN置为1，ACk = x +1 生成新的随机数seq = Y
    （3）浏览器收到服务端的消息后，将返回随机数seq  = Y+1 应答位ACK = seq +1
    返回浏览器，最终完成此次连接请求。
四次挥手：
    （1）主动方将FIN 置为1 ，并将上次最终连接成功的随机数放置在seq= x上，
    发起断开请求，
    （2）被动方收到后，将FIN置为1，并将随机数ACK = seq+1，生成一个新的随机数
    seq = Y，发送主动方，表示知道断开请求。等待发送最终的断开连接请求。
    （3）被动方等待所有事务执行完毕，将结束标志置为FIN = 1，ACK = seq+1 生成新的随机数seq=Y
    （4）主动方收到后，返回应答位ACK =x seq = Y表示要断开连接。
```



##### 13、谈谈你对python 生成器 迭代器的理解

```python
生成器迭代器：
	相同点：
		都具有：__iter__(),__next__()方法，
	不同点：
		创建方式：
			迭代器：通过__iter__()方法创建，
			生代器：通过yiled 关键字创建，或者生成器函数创建，
		返回方式：
			迭代器：调用next（）方法，一次性返回，内存开销大，消耗内存。
			生代器：调用next（）方法，调用一次，返回一次，占用空间小，节省内存。
```



##### 14、缓存穿透，缓存击穿，缓存雪崩

```python
redis缓存穿透：
	缓存中没有，去DB库中查找，db中也没有数据，就不会设置缓存，如果有恶意攻击者就可		能导致服务器压力过大。
    解决方法：如果db中也查询不到数据，也放入缓存，只不过放入的是null值，设置的过期		时间相较于其他的key短一些，
redis缓存击穿：
	热点场景的key在某个时间点过期，恰好有大量的请求并发过来，造成DB压力。
    解决方法：设置热点key永不过期。
redis缓存雪崩：
	是指大量缓存在一段时间内过期，发生大量缓存击穿，所有查询都落在数据库上面，造成			缓存雪崩
    解决方法：合理的设置缓存过期时间，在缓存过期时间上面加一个随机数，合理的规避同			时过期。
```



##### 15、csrf攻击原理  如何解决

```python
原理：
	用户访问A安全页面，登陆后缓存下cookie，A页面有B页面不安全链接，诱惑用户点击之后，B页面设置访问需携带cookie，B就拥有cookie，构造请求，以用户的身份访问A安全页面，操作用户的信息。
解决方法:
    1、使用json API
    ajax的请求可以限制跨域，并不能通过简单的表单来发送json，所以，只通过接收json的方式可以很大的避免CSRF攻击。
    2、验证HTTP的Referer字段，如果是A网站的网址域名。
```



##### 16 、同步互斥锁 乐观锁 悲观锁

```python
（1）同步互斥锁：
	为了较好的处理线程并发下的数据资源操作，同步锁实现了，在一个线程操作此资源时，给此线程上锁，等待任务完成释放锁之后，下一个线程在运行。
    悲观乐观锁是针对于数据库管理系统中并发任务时，为保持事务的统一性，隔离性以及数据库的统一性，而产生的锁机制。
（2）乐观锁：
	是指每次取数据都假象没有人修改数据，但是在提交的时候，会判断一下在此期间有没有人去更新数据，
		适用于：多用数据竞争不大冲突较少的环境中，这样事务回滚的成本就小于上锁阻塞的成本，从而会获得更大的并发量。
（3）悲观锁：
	是指，每次去数据库拿数据的时候，假象都会有人修改数据，所以每次都上锁，直到动作完成释放锁，这样就会早成共享资源，在多线程的时候阻塞，这个原理跟python的		GIL一样
    	适用于：主要适用于线程对共享资源竞争激烈的环境中，避免回滚次数多。
```



##### 17、简述 进程 线程 协程

```python
进程：操作系统分配的资源最小单位。
线程：是cpu调度的最小单元。
协程：轻量级的线程，是单线程下的并发过程。

进程&线程的关系：
	线程在进程中运行，
	进程中的所有线程共享进程中的资源，
	线程本身不具有系统资源。
	进程退出时，所有线程都会推出。

进程&线程的区别：
    进程，是cpu分配资源和调度的最小单位， 线程是进程运行的最小单元，
    拥有资源：进程拥有系统分配的资源，而线程共享进程的资源，本省不具有系统资源。
    系统开销：进程创建消耗系统资源大，线程消耗少
   
协程：
	协程：
		1、就是协同多任务，
		2、是通过异步函数实现的，
		3、执行在线程之内，它的上下文切换不是由cpu控制的，对于cpu来说，并不存在协程的概念，
		4、是人为在线程中通过代码进行定义，一个线程中可以存在多个协程。
	实现：
		可通过yiled函数实现，
		python自带：asyncio模块 async ，await 关键字实现。
```



##### 18、简述tcp udp，举几个tcp防止粘包的策略

```python
TCP&UDP:
    相同点：
    	是一种网络传输协议，
    不同点：
    	1、tcp是面向连接的，面向流的，UDP是无连接面向消息的，
        2、tcp相比于udp是一种可靠的传输协议，而udp相较于tcp是一种在乎传输速度对数据的实时性要求比较高的时候使用。

粘包 ： tcp传输是一种数据流传输方式，当数据传输到缓冲区时因为没有消息边界，会造成数据混乱，导致取出的消息错乱，
策略：
    （1）人为添加消息边界
    （2）发送消息时，设置合理的时间间隔。
UDP是面向消息传输的，有消息保护边界，因此不存在粘包现象。
```



##### 19、celery

```
celery是一个处理大量消息的分布式系统。是一种生产者消费者的设计模式
由消息中间件，任务执行单元、任务执行结果储存三部分构成。
在项目中，配置好安装配置好celery，用redis作为任务队列，主要用来发送邮件，在qq邮箱发送的过程中，会阻塞，将任务放到队列中，去让celery任务执行单元去执行，程序继续往下走，能给用户带来更好的体验。
```



##### 20 、redis

```
redis是一种单线程，非关系型数据库，他所有数据都存储再内存之中，所有运算都是内存级别的运算。所以运算速度不是他的瓶颈，因为他是单线程的，所以避免了在线程之间来回切换的性能损耗。
redis可以做缓存，可以做消息队列。

Redis的五种数据类型
	字符串、列表、hash、集合、有序聚合（根据分数排序）
```



#####  21、 cookie，session，token

```
cookie：可以单独进行登录验证：
	优点：
        扩展性可用性高，
        cookie中只存放不敏感信息，即使被盗也不会有太大损失。
	缺点是：
        1、cookie可能会被拦截，伪造cookie向服务器发送恶意请求，
        2、cookie的数量有有限，
        3、如果用户将浏览器设置为禁止使用cookie，那cookie就无法使用
        4、不能跨域
session: session的sessionID存储在客户端的cookie中，每次发送请求，都会将session带到服务器进行验证。
    缺点：
        跟cookie不兼容一样。
    优点：
        1、session保存在服务器端，相对比较安全。
        2、结合cookie使用，相对比较灵活，兼容性好。以为cookie的兼容性好。
token：
	优点：
        1、可以解决http无状态的问题
        2、可以解决跨域问题。
        3、更适用于移动端，因为移动端不支持cookie。
		
	缺点：
        1、占带宽
            要比sessionID大，需要消耗更多流量
        2、性能下降
            大多数 Web 身份认证应用中，JWT 都会被存储到 Cookie 中，就是说有了两个层面的签名。
            为此，需要花费两倍的 CPU 开销来验证签名
```



##### 22 、简述 几种 IO多路复用，并说明其原理特性

```
IO堵路复用的三种方式select poll epoll：
	（1）select ：支持水平触发，在cup内核中映射当IO可以执行的时候就通知应用程序执行，但是不会告知是哪个事件就绪，只得将所有的就绪的事件都拿出来，让应用程序			自己选择
          select 监控的文件描述符是固定的。
		作用： 消耗的资源少，效率高
	（2）poll 支持水平触发，poll监控的文件描述符数量大于select 
	（3）epoll  既支持水平也支持边缘触发。
            边缘触发 ： 在cup内核中直接开辟一片空间注册发生的IO事件，有IO事件发生的时候，
                    会通知应用程序有事件可以执行了，并会将执行的事件直接告知应用程序，不用程序自己再去找。
```



##### 23、简述面向对象中__new__和__init__区别

~~~python
（1）__new__()函数是类准备实例化的时候内部调用的，而且至少需要传一个参数cls表示实例化当前的类。并且需要返回值，表示实例化的哪个类。并且没有返回值的话，		__init__()函数将不会被调用。
（2）__init__()函数是在__new__()函数的基础上完成了初始化的动作，不需要返回值，创建的每一个实例都有自己的属性。
~~~



##### 24、redis持久化

```python
（1）RDB模式--快照--二进制存储磁盘，
    --执行命令BGSAVE 会fork()出一个子进程执行磁盘写入
（2）AOF 存储命令，开启主机时直接执行所有命令，就写入了.
```



##### 25、redis主从复制

```python
只有master能写命令，其他从进行读操作，实际场景读的压力本来就比写多，分散了高并发下读压力；
实现方式 ： 
	（1）终端命令 
		服务端：redis-server --port6300 -- slaveof 127.0.0.1: 6379  
		客户端：redis-cli -p 6300
	（2）redis命令行 
	（3）哨兵 ： 主master挂了之后，会自动找出一个主执行slaveof no one 并将剩余的从执行master。
```



##### 26、python的垃圾回收机制

```
1、引用计数 : 内存被引用总个数 
    缺点不能解决循环引用问题,容易造成内存浪费,
2、标记清除 : 解决引用计数的循环引用问题;扫描内存,
    查看是否存在无法访问的内存空间。
    缺点：扫描内存耗时长；
3、分待回收 ：将内存划分为多个区域，创建对象时，将对象放入第一个内存中，内存满了之后，将进行标记清除，将有用的数据放入下一代，依次进行。 
    作用 ：   解决扫描时间长；
    年轻代 ： 新创建对象处于年轻代
    中年代 ： 年轻代存满了的时候进行标记清除，将有用的数据移动到中年代
    老年代 ： 中年代存满了时，进行标记清除，将有用的数据移动到老年代。
```



##### 27 http与https得区别

```
1、http是超文本传输协议，信息是明文传输得，https是由ssl加密得加密传输协议；
2、http与https使用得是完全不同得连接方式，使用得端口号也不一样。前者是80 后者是443
3、http连接很简单基于tcp连接，是无状态的，https协议是由ssl+http协议构成的可进行加密传输身份认证的网络协议，比http安全。
```



 ##### 28、sql注入原理

```python
sql 注入是攻击者通过前端输入操作，将输入的语句或字符，插入到后台sql执行的语句中，达到对服务器进行攻击的目的。
```



##### 29、数据库的优化

```
	数据库的优化这一块，主要针对索引字段进行了优化，
	1、从服务层面增强：
		配置mysql性能优化参数
	2、从系统层面增强
	（1）宗从数据库三范式， 数据库范式优化		
		数据库范式 ：--数据表设计总结--减少冗余-清晰展现数据表关系，
		第一范式：每个字段是单一数据类型，
		第二范式：要求字段不能存在依赖关系，将一对多的关系存在一个表中，一个表中必须存在一个主键，其他字段可以依赖主键来查询，
		第三范式: 不同表中不能存在相同的重复字段数据；
	（2）字段数据类型选择优化： 尽量选择与当前字段符合的字段类型，例如能用varchar，就不使用char。
	（3）键的设置优化--提高查询速度。尽量设置占用空间小，选择性高的字段作为主键，
	（4）查询等级的优化；--查询时尽量设计使用查询等级高的；至少在range级别以上；
	（5）表的拆分；--将经常查询的放在一起，
	（6）sql语句的优化，避免使用模糊查询，（如百分号不前置，尽量避免全表扫描is，like ，in or等查询语句会使全表扫描），使用join来代替子查询，
```



##### 30、处理数据库高并发 

```python
1，服务器配置 ： nginx  反向代理（nginx集群）
2，缓存 ： 强缓 ，协商缓存  
3，数据库的集群，库表散列部署
4，数据一致性，加个悲观锁，环境中使用
5， html页面静态化 使用缓存加载页面。 
```



##### 31、数据库引擎之间的区别

~~~python
innodb ：
	支持行级锁  支持事务  查询效率不如myisam 
myisam
	不支持事务  支持表级锁，  查询效率高于innodb
总结：
	查询操作多  使用myisam 
	写入、修改、删除、操作多，可用innodb
~~~



##### 32、事务的4个特性

~~~python
事务的四个特性分别如下：
	（1）原子性：执行事务时要么全部成功 要么全部失败。
	（2）一致性：终端查看的数据都保持一致
	（3）隔离性：修改过程中未提交的数据之前对其他事务是不可见的
	（4）永久性：事务提交后对数据库的修改是永久性的。
	
	优缺点：
        缺点 ：
            事务在创建执行的过程中会对操作的数据表加锁，
            所以事务会降低数据的增删改查的效率，
        优点　：
            事务保证了数据的一致性。      
    数据库的笛卡尔积：
        是指两个数据集合的乘积，两两组合产生出来的新的集合。
~~~



##### 33、中间件

~~~python
中间件 : 
	django插件 
    	作用 : 用于全局改变django的输入输出,放在特殊的位置上,改变全局的请求或响应. 
	1、process_request()--------进入路由之前被调用,（可用作反爬）
		返回None ：正常请求，HttpResponse：异常请求拦截
	2、process——view（callback）-------进入视图函数之前，
		返回None ：正常请求，HttpResponse：异常请求拦截		
	3、process_response()--------响应浏览器之前
		返回值  只能是HttpResponse ：正常异常看 响应
	4、 Process——execption（）-----处理过程中抛错时调用，截获异常。
	5、Process_template_response() ----视图刚好执行完成之后被调用
~~~



##### 34、django请求的生命周期

~~~python
1、浏览器请求通过wsig进入django中,
	我们如果配置了中间件的话,先通过process_request,返回值为None则直接进入路由层,如果返回HttpResponse,则进入process_response()中通过wsgi返回浏览器,我们假设他进入了路由层,那他通过url找到相应的视图函数,在进入视图函数之前,先经过process_view中间件,返回值为None则通过校验,进入视图,如果为HttpResponse,则进入process_response()中,最终返回浏览器,在视图中数据交互找model,页面交互,找静态文件,再交互过程中如果出了问题,会进入procees_execaption()中间件,经过process_response()中间件,最终返回浏览器错误信息,若果一切顺利,则最后通过process_response()中间件,
最后返回浏览器响应,至此django声明周期结束.


Django框架遵循MVC设计，并且有一个专有名词：MTV
    M全拼为Model，与MVC中的M功能相同，负责数据处理，内嵌了ORM框架
    T全拼为Template，与MVC中的V功能相同，负责封装构造要返回的html，内嵌了模板引擎
    V全拼为View，与MVC中的C功能相同，接收HttpRequest，业务处理，返回HttpResponse
~~~



##### 35、浏览器缓存

~~~python
强缓存 ： 
		expires :----- http1.1
		Cache-control --http1.0  (浏览器优先查询)
		在浏览器第一次发起请求时，服务器在响应头中添加Expires/Cache-control 触发浏览器强缓存机制,
		两种触发机制都有一个过期时间,在过期时间之内,浏览器在请求资源时,根据expries或者Cache-control
		判断是否命中强缓存，命中直接访问缓存，没有命中发送请求到服务器。
强缓存属性 ：public： 服务器端和浏览器端都能缓存
                private: 只能浏览器端缓存
                no-store: 不缓存，使用协商缓存
                max-age=60：设置缓存存储的最大周期（单位秒）
                only-if-cached: 表明客户端只接受已缓存的响应，并且不要向原始服务器检查是否有更新的拷贝。
协商缓存：
		Last-Modifiled -----http 1.0  ----浏览器第一次设置缓存时返回的数据最后修改时间。
		Etag   ------------http 1.1 (浏览器优先查询)   ----浏览器第一次设置缓存时返回的数据的hash运算值
		若果强缓存时间到期或者没有设置过期时间,浏览器访问时会将If-Modified-Since携带到后端,
		后端核对后,如果数据未发生改变浏览器数据继续使用,如果已经修改了,则重新返回新的数据，
		并返回最新的数据修改时间。

		Etag 验证数据跟上面的流程基本一致,浏览器验证会携带If-None-Match，
		使用数据哈希运算进行前验证hash值是否改变，改变就说明数据已修改。
		
		
		相同情况下Last-Modified要比Etag效率高,Etag需要哈希运算。
~~~



##### 36、什么是es

```python
elasticsearch是一个数据存储、数据搜素、数据分析为一体的系统，他是分布式的，具有高可用和很强的伸缩性，可以作为一个全局搜素服务器。
	1、数据存储：数据以json格式存储，可单独作为一个数据存储工具，
    2、数据搜索：它能够对保存的json数据根据需要，进行多种方式搜索搜索，
    3、数据分析：对json文档数据进行分析，得出结论。
```



##### 37、elasticsearch中的集群，节点，索引，文档，类型，映射、分片是什么

```python
集群：
	集群是一个或者多个节点（服务器）的集合，它提供跨所有节点的联合搜索功能，集群有唯一的名称标识，
节点：
	节点是集群中的单个服务器，
索引：
	索引就像关系型数据库中的数据库，就像我有一个school数据库，索引就对应的是这个数据库；
类型：
	类型相当于关系数据库中的表，
文档：
	文档相当于关系数据库中的每行数据；
映射:
    映射指文档中的字段的各种属性；
分片：
	分片是位于节点上的，有主分片副分片之分，es中的数据存储在分片上，当一个文档存储的时候会先在主分片上存储，再复制到副分片上，主分片与副分片存储再不同的节点	上，实现了数据的高可用。
索引指引数据属于那个数据库，类型指引数据属于那个表，文档指引数据在哪一行。
mapping（映射）定义整体的index（索引）的document（文档）的结构，和影响分词策略
    	
```

##### 38、简述同源策略

```python
同源策略需要同时满足以下三点要求： 
	1）协议相同 
	2）域名相同 
	3）端口相同 
 http:www.test.com与https:www.test.com 不同源——协议不同 
 http:www.test.com与http:www.admin.com 不同源——域名不同 
 http:www.test.com与http:www.test.com:8081 不同源——端口不同
            
在浏览器窗口中，和某个服务端通过某个 “协议+域名+端口号” 建立了会话的前提下，去使用与这三个属性任意一个不同的源提交了请求，那么浏览器就认为你是跨域了违反了浏览器的同源策略

解决方法:
    方法1:安装django-cors-headers  配置settings文件
	方法2:使用JSONP
    方案3.直接修改Django中的views.py文件,原理是修改请求头
    	#修改views.py中对应API的实现函数，允许其他域通过Ajax请求数据：
        def myview(_request):
            response = HttpResponse(json.dumps({“key”: “value”, “key2”: “value”}))
            response[“Access-Control-Allow-Origin”] = “*”
            response[“Access-Control-Allow-Methods”] = “POST, GET, OPTIONS”
            response[“Access-Control-Max-Age”] = “1000”
            response[“Access-Control-Allow-Headers”] = “*”
            return response

```

##### 39、django的ORM是什么

~~~python
ORM:
    O Object    对象
    R Relations 关系
    M mapping   映射
    
    django的ORM是一中对象关系映射，主要作用是实现数据库的解耦，数据模型的设计不再依赖特定的数据库
    类名 对应数据库中的表名
    类属性 对应数据库中表字段
    类实例 对应数据库里一行数据
~~~

##### 40、CBV和FBV

    ~~~python
FBV:
	在视图里使用函数处理请求
CBV:
    在视图里使用类处理请求。

    ~~~
    
    ~~~

##### 40.1、简述MVC和MTV

~~~python
MVC：model、view(模块)、controller(视图)
MTV：model、tempalte、view
~~~





##### 41、django的ORM操作

~~~python
1.django对数据查询结果排序怎么做,降序怎么做:
    
    user = Users.objects.order_by(‘id’)
    user = Users.objects.order_by(‘id’)[0:1]
    # 如果需要逆序 在字段前加负号 例 （‘-id’）
    
2.django中orm如何查询id不等于5 的元素:
    User.objects.filter().exclude(id=5)    # 查询id不为5的用户

3.only和 defer的区别?

	1.只取id/name/age字段
        models.User.objects.all().only("id", "name", "age")
    2.除了name字段
        models.User.objects.all().defer("name")
        
4.django中 values和 values list的区别?

    values 字典列表,ValuesQuerySet查询集
    <QuerySet [{'id': 2, 'name': '作者2', 'age': 24}, {'id': 3, 'name': '作者3', 'age': 35}]>
    
    values_list 返回元祖列表,字段值
    <QuerySet [(2, '作者2', 24), (3, '作者3', 35)]>

5.django中的Q的作用?
	对对象进行复杂查询，并支持&（and）,|（or），~（not）操作符

6.django中的F的作用?
	操作数据表中的某列值

    
 
~~~

##### 43、ORM中的数据库操作方法

~~~python
    返回QuerySet对象
        all    ------  返回所有数据
        filter --------  过滤指定数据
        exclude --------  反向搜索，不包含什么数据 
        order_by -------  排序  倒序加 order_by('-age')
        reverse  
        distinct— -------  去重
        values  -----------  查询结果为一个字典的列表
        values_list ------ 擦汗寻结果为一个元组的列表
        .only("id", "name", "age")--- 仅仅包含这三个字段 
        .defer("name") --------------- 除过name的其他字段
    返回对象
        get ----------- 获取数据
        first ---------  获取第一个数据
        last ----------- 获取最后一个数据
    返回数字
        count ----------- 返回查询数量
    返回布尔值
        exists  ---------  是否存在数据
        

~~~



##### 44、从输入http://www.baidu.com到页面返回,中间都是发生了什么?

~~~python
1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;
2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;
3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 		TCP 三次握手的第三个报文的数据发送给服务器;
4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;
5、释放 TCP连接;
6、浏览器将该 html 文本并显示内容;


~~~

